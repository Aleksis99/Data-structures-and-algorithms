## Задачи

**Задача 1:** Даден е списък **l** с елементи списъци от естествени числа в интервала [0,..,9]. От всеки списък l_i получаваме две числа по следния начин:  

- Обхождайки го отпред назад, получваме число n_i.  
- Обхождайки го отзад напред, получаваме число n_i_reversed.  

Да се дефинира функция, която *намира сумата n_i + n_i_reversed за 0 <= i <= l.size() - 1*.  

*Вход:* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*Изход:*

```c++
1 -> 2                        809
|                             (12 + 21 + 234 + 432 + 55 + 55)
v
2 -> 3 -> 4
|
v
empty
|
v
5 -> 5
```

**Задача 2 (Контролно 2021):** Даден е списък **l** с n елемента.  
Да се дефинира функция *shuffle()*, която получава адреса на първия елемент на списъка. Функцията да пренарежда възлите на списъка така, че *елементите от втората половина на списъка да се преместят в началото на списъка, но в обратен ред* (при списъци с нечетен брой елементи считаме средния елемент за принадлежащ към първата половина на списъка).  

*Пример:*
*L1 → L2 → L3 → L4 → L5 се преобразува до L5 → L4 → L1 → L2 → L3*  

**Задача 3 (Контролно 2023):**
Нека израз има следния вид:

- латинска буква, което се оценява до true;
- друг символ, което се оценява до false;
- `!(expr)`, което е логическо отрицание на вътрешния израз expr;
- `&(expr1, expr2, ...)`, което е логическо И на 2 или повече израза expr1, expr2, ...;
- `|(expr1, expr2, ...)`, което е логическо ИЛИ на 2 или повече израза expr1, expr2, ...;

Да се напише функция, която по подаден булев израз връща неговия резултат. За изчислението се позволява използването единствено на структура от данни стек. Позволено е използване на помощни функции.

*Символите не са оградени в допълнителни кавички в подадения израз.*

**Примери:**

1. `!('*') => true`
2. `|('*', 'a') => true`
3. `&('B', '-') => false`
4. `|(&('c', '+', 'Z'), !('s')) => false`

**Задача 4 (Контролно 2023)** Напишете функция, която получава като аргумент указател към елемент на двусвързан цикличен списък **с елементи от тип T** (без фиктивен елемент) и премахва от него всички елементи, които се делят без остатък на двата си съседа (допуска се, че за тип T са дефинирани нужните операции). След изпълнение на функцията списъкът трябва да остане валиден и да не съдържа елементи с това свойство.

```cpp
template <typename T>
struct DCLE {
    T inf;
    DCLE<T> *next;
    DCLE<T> *prev;
};
```

**Пример за тип unsigned:**

[2] ↔ [4] ↔ [7] ↔ [1] ↔ [6] ↔ [12]

[4] ↔ [2] ↔ [7] ↔ [1]

Подaва се указател към 2.  
Първо се изтрива 12 (дели се на 2 и 6),  
а после се изтрива 6 (дели се на 2 и 1).
