# Йерархични структури от данни (Hierarchical data structures)

Йерархичните структури от данни имат главна стойност, която се нарича корен (root), от която тръгват разклонения от възли, които оформят йерархична връзка на принципа parent-child. Всеки възел, от който произлизат едно или повече разклонения, се води родител или parent, а подчинените му възли са дете или child. По този начин се създава сложна разклоняваща се структура.  

#### Наредба на елементите при линейни и йерархични структури:
Нека R е релация (елементите й са от вида <x,y>) и <x,y> ∈ R <=> x е предшественик на y. Тогава:  
Множеството от елементите на йерархичните структури, заедно с релацията "предшествие" образуват ***частично наредено множество*** (не всеки два елемента могат да бъдат сравнени по критерия "предшествие").  
Множеството от елементите на линейните структури от данни, заедно с релацията "предшествие" образуват ***линейно наредено множество*** (нямаме несравними елементи по критерия "предшествие").  

## Дървета 
![alt_text](https://i.ibb.co/MZcSHQM/Binary-tree.png)

### Двоични дървета
Ще ги редставяме със следната структура  
```c++
template <typename T>
struct Node
{
	T data;

	Node* left;
	Node* right;
};

Node<int>* root = new Node<int>(2);
Node<int>* n1 = new Node<int>(7);
Node<int>* n2 = new Node<int>(5);
Node<int>* n3 = new Node<int>(2);
Node<int>* n4 = new Node<int>(6);
Node<int>* n5 = new Node<int>(9);
Node<int>* n6 = new Node<int>(5);
Node<int>* n7 = new Node<int>(11);
Node<int>* n8 = new Node<int>(4);

root->left = n1;
root->right = n2;
n1->left = n3;
n1->right = n4;
n2->right = n5;
n4->left = n6;
n4->right = n7;
n5->left = n8;
```
### N-ични дървета
Ще ги представяме със следната структура  
```c++
template <typename T>
struct NodeFull
{
	T data;

	vector<NodeFull<T>*> children;
};
```

## Задачи

**Задача 1:** Да се напише функция, която приема указател към корена на двоично дърво и елемент и връща *дали елементът се съдържа в него*.  

**Задача 2:** Да се напише функция, която приема указател към корена на двоично дърво от числа и връща *сумата на числата в него*.  

**Задача 3:** Да се напише функция, която приема указател към корена на двоично дърво и връща *най-големия елемент в него*.  

**Задача 4:** Да се напише функция, която приема указател към корена на двоично дърво и връща *височината му*.  

**Задача 5:** Да се напише функция, която приема указател към корена на двоично дърво и връща *броя на елементите му*.  

**Задача 6:** Да се напише функция, която приема указател към корена на двоично дърво с n върха и връща *дали числата от 1 до n се срещат точно веднъж в дървото*.  

**Задача 7:** Да се напише функция, която приема указател към корена на двоично дърво, чиито елементи са символи, и цяло число k и връща *думата на k-тото ниво на дървото*.  

 **Задача 8:** Да се напише функция, която приема указател към корена на двоично дърво и връща *всички думи, които се получават обхождайки дървото от корена до някое листо*.  

```c++
Node<char>* root = new Node<char>('a');
Node<char>* n1 = new Node<char>('b');
Node<char>* n2 = new Node<char>('c');
Node<char>* n3 = new Node<char>('d');
Node<char>* n4 = new Node<char>('e');
Node<char>* n5 = new Node<char>('f');
Node<char>* n6 = new Node<char>('g');
Node<char>* n7 = new Node<char>('h');
Node<char>* n8 = new Node<char>('i');
root->left = n1;
root->right = n2;
n1->left = n3;
n1->right = n4;
n2->right = n5;
n4->left = n6;
n4->right = n7;
n5->left = n8;
```

**Задача 9:** Да се напише функция, която приема указател към корена на двоично дърво и връща *сумата на листата му*.  

**Задача 10:** Напишете функция, която приема указател към корена на двоично дърво и *обхожда елементите му по следния начин: ляво - корен - дясно (Inorder Traversal)*.  

**Задача 11:** Напишете функция, която приема указател към корена на двоично дърво и *променя дървото в неговата огледална форма*.  

**Задача 12:**  
Троично дърво от латински букви ще наричаме следната структура:
1. Празното дърво е троично дърво от латински букви;
2. Ако $T_1, T_2$ и $T_3$ са троични дървета от латински букви, а $x$ е буква от латинската азбука, то наредената четворка $<x, T_1, T_2, T_3>$ също е троично дърво от латински букви.


Напишете програма, която зарежда информация за троично дърво от файл и след това извежда думите, които се намират на всяко от неговите нива. Всяка дума трябва да се изведе на отделен ред. Например за даденото долу дърво, програмата трябва да изведе следния текст:

```
b
xy
pqrs
cat
```

![alt_text](https://i.ibb.co/FzLxMZv/Screenshot-2024-11-15-155412.png)

Троично дърво се представя във файл по следния начин:
1. Текстовото представяне на празното дърво е звездичка ("*");
2. Текстовото представяне на троичното дърво $<x, T_1, T_2, T_3>$ е "(x R_1 R_2 R_3)", където $R_1, R_2$ и $R_3$ са текстовите представяния съответно на $T_1, T_2$ и $T_3$.

Например, текстовото представяне на дървото от примера, ще бъде:

```
(b (x (p * * *) (q * * *) (r (c * * *) * (a * * *))) (y * * (s * (t * * *) *)) *)
```

В решението на задачата можете да използвате контейнерите от STL. Реализирайте операциите така, че те да се извършват с колкото се може по-ниска сложност.