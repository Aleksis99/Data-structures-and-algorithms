# Двоично наредено дърво (Binary search tree)

**Каква е мотивацията за структурата двоично наредено дърво?**  
Искаме колекция, която поддържа следните операции:  
- добавяне на елемент  
- търсене на елемент  
- премахване на елемент  

***Двоично наредено дърво***  
Двоично дърво, при което:  
- Стойностите на всички върхове в ***лявото*** поддърво са ***по- малки*** от стойността на корена.  
- Стойностите на всички върхове в ***дясното*** поддърво са ***по- големи*** от стойността на корена.  

![alt_text](https://i.ibb.co/nfc67cY/BST.png)

 n-тото ***число на Каталан*** е точно ***броят двоично наредени дървета с n върха***.  

![alt_text](https://i.ibb.co/BzW1ccs/Catalan.png)

***Добавяне на елемент (Insert)***  

![alt_text](https://i.ibb.co/k0QddwB/Insert-in-BST.png)

***Премахване на елемент (Remove)***  
- Първи случай (**Премахваме листо**)  

![alt_text](https://i.ibb.co/WB9wLQX/Remove-first-case.png)

-  Втори случай (Премахваме **възел с две деца**)  

![alt_text](https://i.ibb.co/2cKJkkv/Remove-second-case.png)

-  Трети случай (Премахваме **възел с едно дете**)  

![alt_text](https://i.ibb.co/GknvGwn/Remove-third-case.png)

***Сложност на операциите в средния случай:***  
| |добавяне|търсене|премахване|  
|--|--|--|--|  
|Двоично наредено дърво|O(log(n))|O(log(n))|O(log(n))|  
|Сортиран масив|O(n)|O(log(n))|O(n)|  

```c++
Node<int>* root = new Node<int>(50);
Node<int>* n1 = new Node<int>(25);
Node<int>* n2 = new Node<int>(75);
Node<int>* n3 = new Node<int>(12);
Node<int>* n4 = new Node<int>(30);
Node<int>* n5 = new Node<int>(60);
Node<int>* n6 = new Node<int>(85);
Node<int>* n7 = new Node<int>(52);
Node<int>* n8 = new Node<int>(70);

root->left = n1;
root->right = n2;
n1->left = n3;
n1->right = n4;
n2->left = n5;
n2->right = n6;
n5->left = n7;
n5->right = n8;
```

## Задачи

**Задача 1:** Да се напише функция, която приема указател към корена на двоично наредено дърво и *създава сортиран масив от елементите му*.  

**Задача 2:** Да се напише функция, която приема указател към корена на двоично дърво от цели числа и проверява *дали то е двоично дърво за търсене(BST)*.  

**Задача 3:** Да се напише функция, която проверява дали две дървета са еднакви.

**Задача 4:** *Huffman decoding*.  
https://www.hackerrank.com/challenges/tree-huffman-decoding/problem  

**Задача 5 (контролно):** Да се напише функция, която *намира сумата на всички елементи на двоично наредено дърво от цели числа, които имат нечетен брой наследници в интервала [x, y]*
(т.е. сумата на броя елементи в лявото поддърво и броя елементи в дясното поддърво в интервала [x, y] е нечетно число).
Нека x и y са параметри на функцията.  

**Задача 6 (контролно):** Да се напише функция, която приема указател към корена на двоично дърво и пресмята *сумата от елементите, които се намират на нечетно ниво и имат само десен наследник*.  
